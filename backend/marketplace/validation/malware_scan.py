"""
Multi-layer malware scanning for .revsyncpkg tune packages.

Scanning layers:
    Layer 1: ClamAV daemon scan (pyclamd)
    Layer 2: YARA rule scan (local ruleset)
    Fallback: Magic byte checks + EICAR string detection

Each layer returns structured results including scanner versions for
audit trail and reproducibility. Layers are additive — a file must
pass ALL available layers to be considered clean.

In development, if ClamAV/YARA are not installed, the fallback
scanner provides basic detection (PE, ELF, Mach-O headers, EICAR).
Set REVSYNC_REQUIRE_CLAMAV=true to enforce ClamAV in production.
"""

import os
import logging
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional

logger = logging.getLogger(__name__)

# EICAR test string — standard antivirus test pattern (harmless)
EICAR_SIGNATURE = b'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*'

# Dangerous magic byte sequences
DANGEROUS_MAGIC: list[tuple[bytes, str]] = [
    (b'MZ',             'PE/Windows executable'),
    (b'\x7fELF',        'ELF binary'),
    (b'\xfe\xed\xfa\xce', 'Mach-O 32-bit'),
    (b'\xfe\xed\xfa\xcf', 'Mach-O 64-bit'),
    (b'\xce\xfa\xed\xfe', 'Mach-O reverse 32-bit'),
    (b'\xcf\xfa\xed\xfe', 'Mach-O reverse 64-bit'),
    (b'#!/',            'Shell script'),
    (b'#!\\',           'Shell script (backslash)'),
]


@dataclass
class ScanResult:
    """Structured result from a malware scan."""
    is_clean: bool = True
    details: list[str] = field(default_factory=list)
    scanner_versions: dict[str, str] = field(default_factory=dict)


def scan_clamav(file_path: str) -> Optional[ScanResult]:
    """
    Scan a file using ClamAV daemon via pyclamd.

    Returns:
        ScanResult if ClamAV is available, None if unavailable.
    """
    try:
        import pyclamd
        cd = pyclamd.ClamdUnixSocket()
        cd.ping()

        # Get scanner version info for audit trail
        version_info = cd.version() or 'unknown'
        scanner_versions = {
            'clamav_version': version_info,
        }

        # Perform the scan
        result = cd.scan_file(file_path)

        if result is None:
            return ScanResult(
                is_clean=True,
                details=['ClamAV: CLEAN'],
                scanner_versions=scanner_versions,
            )
        else:
            virus_info = result.get(file_path, ('FOUND', 'Unknown'))
            virus_name = virus_info[1] if isinstance(virus_info, tuple) else str(virus_info)
            return ScanResult(
                is_clean=False,
                details=[f'ClamAV: INFECTED — {virus_name}'],
                scanner_versions=scanner_versions,
            )

    except ImportError:
        logger.info("pyclamd not installed — ClamAV layer skipped")
        return None
    except Exception as e:
        if os.environ.get('REVSYNC_REQUIRE_CLAMAV', '').lower() == 'true':
            raise RuntimeError(f"ClamAV is required but unavailable: {e}")
        logger.warning(f"ClamAV unavailable ({e}) — layer skipped")
        return None


def scan_yara(file_path: str) -> Optional[ScanResult]:
    """
    Scan a file using YARA rules from the local ruleset directory.

    The rules directory is at marketplace/validation/yara_rules/*.yar.

    Returns:
        ScanResult if YARA is available, None if unavailable.
    """
    try:
        import yara
    except ImportError:
        logger.info("yara-python not installed — YARA layer skipped")
        return None

    rules_dir = Path(__file__).parent / 'yara_rules'
    if not rules_dir.exists():
        logger.warning(f"YARA rules directory not found: {rules_dir}")
        return None

    # Compile all .yar files in the rules directory
    rule_files = sorted(rules_dir.glob('*.yar'))
    if not rule_files:
        logger.warning("No YARA rule files found")
        return None

    try:
        # Compile rules — filepaths dict keyed by namespace
        filepaths = {f.stem: str(f) for f in rule_files}
        rules = yara.compile(filepaths=filepaths)

        # Scan the file
        matches = rules.match(file_path)

        scanner_versions = {
            'yara_version': yara.YARA_VERSION if hasattr(yara, 'YARA_VERSION') else 'unknown',
            'yara_rules_count': str(len(rule_files)),
            'yara_rule_files': ', '.join(f.name for f in rule_files),
        }

        if matches:
            match_names = [str(m) for m in matches]
            return ScanResult(
                is_clean=False,
                details=[f'YARA: MATCH — {", ".join(match_names)}'],
                scanner_versions=scanner_versions,
            )
        else:
            return ScanResult(
                is_clean=True,
                details=['YARA: CLEAN'],
                scanner_versions=scanner_versions,
            )

    except Exception as e:
        logger.error(f"YARA scan error: {e}")
        return None


def scan_mock(file_path: str) -> ScanResult:
    """
    Fallback malware scanner for development environments.

    Checks for:
    - Dangerous executable magic bytes (PE, ELF, Mach-O, shell scripts)
    - EICAR antivirus test string

    This is NOT a substitute for ClamAV/YARA in production.
    """
    scanner_versions = {'scanner': 'mock-fallback-v1'}
    details: list[str] = []
    is_clean = True

    try:
        with open(file_path, 'rb') as f:
            # Read header for magic byte check
            header = f.read(8)

            # Check against known dangerous magic bytes
            for magic, description in DANGEROUS_MAGIC:
                if header[:len(magic)] == magic:
                    is_clean = False
                    details.append(
                        f"MockScan: Executable detected — {description} "
                        f"(magic: {header[:len(magic)].hex()})"
                    )
                    break

            # EICAR test string check (scan first 1KB)
            f.seek(0)
            chunk = f.read(1024)
            if EICAR_SIGNATURE in chunk:
                is_clean = False
                details.append("MockScan: EICAR test string detected")

    except Exception as e:
        details.append(f"MockScan: Read error — {e}")

    if is_clean:
        details.append("MockScan: CLEAN (ClamAV/YARA not available)")

    return ScanResult(
        is_clean=is_clean,
        details=details,
        scanner_versions=scanner_versions,
    )


def scan_layered(file_path: str) -> ScanResult:
    """
    Run all available scanning layers on a file.

    Order: ClamAV → YARA → Mock fallback.
    A file must pass ALL available layers. Results and scanner versions
    are merged into a single ScanResult for the validation report.

    Returns:
        Combined ScanResult with is_clean=True only if all layers pass.
    """
    combined = ScanResult()
    layers_run = 0

    # Layer 1: ClamAV
    clam_result = scan_clamav(file_path)
    if clam_result is not None:
        layers_run += 1
        combined.details.extend(clam_result.details)
        combined.scanner_versions.update(clam_result.scanner_versions)
        if not clam_result.is_clean:
            combined.is_clean = False
            logger.warning(f"ClamAV flagged: {clam_result.details}")

    # Layer 2: YARA
    yara_result = scan_yara(file_path)
    if yara_result is not None:
        layers_run += 1
        combined.details.extend(yara_result.details)
        combined.scanner_versions.update(yara_result.scanner_versions)
        if not yara_result.is_clean:
            combined.is_clean = False
            logger.warning(f"YARA flagged: {yara_result.details}")

    # Fallback: if no real scanners were available, use mock
    if layers_run == 0:
        mock_result = scan_mock(file_path)
        combined.details.extend(mock_result.details)
        combined.scanner_versions.update(mock_result.scanner_versions)
        if not mock_result.is_clean:
            combined.is_clean = False

    combined.scanner_versions['layers_run'] = str(layers_run)

    return combined
